<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MonteCarloMeasurements · MonteCarloMeasurements Documentation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>MonteCarloMeasurements Documentation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li class="current"><a class="toctext" href>MonteCarloMeasurements</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#Basic-Examples-1">Basic Examples</a></li><li class="toplevel"><a class="toctext" href="#Why-a-package-1">Why a package</a></li><li class="toplevel"><a class="toctext" href="#Constructors-1">Constructors</a></li><li class="toplevel"><a class="toctext" href="#Multivariate-particles-1">Multivariate particles</a></li><li class="toplevel"><a class="toctext" href="#Sigma-points-1">Sigma points</a></li><li class="toplevel"><a class="toctext" href="#Latin-hypercube-sampling-1">Latin hypercube sampling</a></li><li class="toplevel"><a class="toctext" href="#Plotting-1">Plotting</a></li><li class="toplevel"><a class="toctext" href="#Differential-Equations-1">Differential Equations</a></li><li class="toplevel"><a class="toctext" href="#Limitations-1">Limitations</a></li><li class="toplevel"><a class="toctext" href="#Overloading-a-new-function-1">Overloading a new function</a></li><li class="toplevel"><a class="toctext" href="#Monte-Carlo-simulation-by-map/pmap-1">Monte-Carlo simulation by <code>map/pmap</code></a></li><li class="toplevel"><a class="toctext" href="#ℝⁿ-ℝⁿ-functions-1">ℝⁿ → ℝⁿ functions</a></li><li class="toplevel"><a class="toctext" href="#ℂ-ℂ-functions-1">ℂ → ℂ functions</a></li><li class="toplevel"><a class="toctext" href="#Weighted-particles-1">Weighted particles</a></li><li class="toplevel"><a class="toctext" href="#When-to-use-what?-1">When to use what?</a></li><li><a class="toctext" href="#Comparison-to-nonlinear-filtering-1">Comparison to nonlinear filtering</a></li><li class="toplevel"><a class="toctext" href="#Examples-2">Examples</a></li><li><a class="toctext" href="#[Control-systems](https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/controlsystems.jl)-1">Control systems</a></li><li><a class="toctext" href="#[Latin-Hypercube-Sampling](https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/lhs.jl)-1">Latin Hypercube Sampling</a></li><li><a class="toctext" href="#[How-MC-uncertainty-propagation-works](https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/transformed_densities.jl)-1">How MC uncertainty propagation works</a></li><li><a class="toctext" href="#[Robust-probabilistic-optimization](https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/robust_controller_opt.jl)-1">Robust probabilistic optimization</a></li><li><a class="toctext" href="#[Autodiff-and-Robust-optimization](https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/autodiff_robust_opt.jl)-1">Autodiff and Robust optimization</a></li><li><a class="toctext" href="#Monte-Carlo-sampling-properties-1">Monte-Carlo sampling properties</a></li><li><a class="toctext" href="#Variational-inference-1">Variational inference</a></li><li class="toplevel"><a class="toctext" href="#Exported-functions-and-types-1">Exported functions and types</a></li><li><a class="toctext" href="#Index-1">Index</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li><a href>MonteCarloMeasurements</a></li></ul><a class="edit-page" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/docs/src/index.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>MonteCarloMeasurements</span><a class="fa fa-bars" href="#"></a></div></header><p><img src="figs/logo.svg" alt="logo"/> <a href="https://travis-ci.org/baggepinnen/MonteCarloMeasurements.jl"><img src="https://travis-ci.org/baggepinnen/MonteCarloMeasurements.jl.svg?branch=master" alt="Build Status"/></a> <a href="https://codecov.io/gh/baggepinnen/MonteCarloMeasurements.jl"><img src="https://codecov.io/gh/baggepinnen/MonteCarloMeasurements.jl/branch/master/graph/badge.svg" alt="codecov"/></a></p><h1><a class="nav-anchor" id="MonteCarloMeasurements-1" href="#MonteCarloMeasurements-1">MonteCarloMeasurements</a></h1><p>This package facilitates working with probability distributions by means of Monte-Carlo methods, in a way that allows for propagation of probability distributions through functions. This is useful for, e.g.,  nonlinear <a href="https://en.wikipedia.org/wiki/Propagation_of_uncertainty">uncertainty propagation</a>. A variable or parameter might be associated with uncertainty if it is measured or otherwise estimated from data. We provide two core types to represent probability distributions: <code>Particles</code> and <code>StaticParticles</code>, both <code>&lt;: Real</code>. (The name &quot;Particles&quot; comes from the <a href="https://en.wikipedia.org/wiki/Particle_filter">particle-filtering</a> literature.) These types all form a Monte-Carlo approximation of the distribution of a floating point number, i.e., the distribution is represented by samples/particles. Correlated quantities are handled as well, see <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl#multivariate-particles">multivariate particles</a> below.</p><p>Although several interesting use cases for doing calculations with probability distributions have popped up (see <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl#examples-1">Examples</a>), the original goal of the package is similar to that of <a href="https://github.com/JuliaPhysics/Measurements.jl">Measurements.jl</a>, to propagate the uncertainty from input of a function to the output. The difference compared to a <code>Measurement</code> is that <code>Particles</code> represent the distribution using a vector of unweighted particles, and can thus represent arbitrary distributions and handle nonlinear uncertainty propagation well. Functions like <code>f(x) = x²</code>, <code>f(x) = sign(x)</code> at <code>x=0</code> and long-time integration, are examples that are not handled well using linear uncertainty propagation ala <a href="https://github.com/JuliaPhysics/Measurements.jl">Measurements.jl</a>. MonteCarloMeasurements also support correlations between quantities.</p><p>A number of type <code>Particles</code> behaves just as any other <code>Number</code> while partaking in calculations. After a calculation, an approximation to the <strong>complete distribution</strong> of the output is captured and represented by the output particles. <code>mean</code>, <code>std</code> etc. can be extracted from the particles using the corresponding functions. <code>Particles</code> also interact with <a href="https://github.com/JuliaStats/Distributions.jl">Distributions.jl</a>, so that you can call, e.g., <code>Normal(p)</code> and get back a <code>Normal</code> type from distributions or <code>fit(Gamma, p)</code> to get a <code>Gamma</code>distribution. Particles can also be iterated, asked for <code>maximum/minimum</code>, <code>quantile</code> etc. If particles are plotted with <code>plot(p)</code>, a histogram is displayed. This requires Plots.jl. A kernel-density estimate can be obtained by <code>density(p)</code> is StatsPlots.jl is loaded.</p><p>Below, we show an example where an input uncertainty is propagated through <code>σ(x)</code></p><p><img src="figs/transformed_densities.svg" alt="transformed densities"/></p><p>In the figure above, we see the probability-density function of the input <code>p(x)</code> depicted on the x-axis. The density of the output <code>p(y) = f(x)</code> is shown on the y-axis. Linear uncertainty propagation does this by linearizing <code>f(x)</code> and using the equations for an affine transformation of a Gaussian distribution, and hence produces a Gaussian approximation to the output density. The particles form a sampled approximation of the input density <code>p(x)</code>. After propagating them through <code>f(x)</code>, they form a sampled approximation to <code>p(y)</code> which correspond very well to the true output density, even though only 20 particles were used in this example. The figure can be reproduced by <code>examples/transformed_densities.jl</code>.</p><p>For a comparison of uncertainty propagation and nonlinear filtering, see <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl#comparison-to-nonlinear-filtering">notes</a> below.</p><h1><a class="nav-anchor" id="Basic-Examples-1" href="#Basic-Examples-1">Basic Examples</a></h1><pre><code class="language-julia">using MonteCarloMeasurements, Distributions

julia&gt; 1 ± 0.1
Part500(1.0 ± 0.1)

julia&gt; p = StaticParticles(100)
SPart100(0.0 ± 0.999)

julia&gt; std(p)
0.9986403042113867

julia&gt; var(p)
0.997282457195411

julia&gt; mean(p)
-4.6074255521943994e-17

julia&gt; f = x -&gt; 2x + 10
#95 (generic function with 1 method)

julia&gt; f(p) ≈ 10 # ≈ determines if f(p) is within 2σ of 10
true

julia&gt; f(p) ≲ 15 # ≲ (\lesssim) tests if f(p) is significantly less than 15
true

julia&gt; Normal(f(p)) # Fits a normal distribution
Normal{Float64}(μ=9.9872274542161, σ=2.1375718437608633)

julia&gt; fit(Normal, f(p)) # Same as above
Normal{Float64}(μ=9.9872274542161, σ=2.1268571304548938)

julia&gt; Particles(100, Uniform(0,2)) # A distribution can be supplied
Part100(1.0 ± 0.58)

julia&gt; Particles(1000, MvNormal([0,0],[2. 1; 1 4])) # A multivariate distribution will cause a vector of correlated particles
2-element Array{Particles{Float64,1000},1}:
 0.0254 ± 1.4
 0.0641 ± 2.0</code></pre><h1><a class="nav-anchor" id="Why-a-package-1" href="#Why-a-package-1">Why a package</a></h1><p>Convenience. Also, the benefit of using this number type instead of manually calling a function <code>f</code> with perturbed inputs is that, at least in theory, each intermediate operation on <code>Particles</code> can exploit SIMD, since it&#39;s performed over a vector. If the function <code>f</code> is called several times, however, the compiler might not be smart enough to SIMD the entire thing. Further, any dynamic dispatch is only paid for once, whereas it would be paid for <code>N</code> times if doing things manually. The same goes for calculations that are done on regular input arguments without uncertainty, these will only be done once for <code>Particles</code> whereas they will be done <code>N</code> times if you repeatedly call <code>f</code>. One could perhaps also make an argument for cache locality being favorable for the <code>Particles</code> type, but I&#39;m not sure this holds for all examples. Below, we show a small benchmark example (additional benchmarks further down) where we calculate a QR factorization of a matrix using <code>Particles</code> and compare it to manually doing it many times</p><pre><code class="language-julia">using BenchmarkTools
A = [Particles(1000) for i = 1:3, j = 1:3]
B = similar(A, Float64)
@btime qr($A)
  119.243 μs (257 allocations: 456.58 KiB)
@btime foreach(_-&gt;qr($B), 1:1000) # Manually do qr 1000 times
  3.916 ms (4000 allocations: 500.00 KiB)</code></pre><p>that&#39;s about a 30-fold reduction in time, and the repeated <code>qr</code> didn&#39;t even bother to sample new input points or store and handle the statistics of the result. The type <code>StaticParticles</code> contains a statically sized, stack-allocated vector from <a href="https://github.com/JuliaArrays/StaticArrays.jl">StaticArrays.jl</a>. This type is suitable if the number of particles is small, say &lt; 500 ish (but expect long compilation times if &gt; 100, especially on julia &lt; v1.1).</p><pre><code class="language-julia">A = [StaticParticles(100) for i = 1:3, j = 1:3]
B = similar(A, Float64)
@btime qr($(copy(A)))
  8.392 μs (16 allocations: 18.94 KiB)
@btime map(_-&gt;qr($B), 1:100);
  690.590 μs (403 allocations: 50.92 KiB)
# Wow that&#39;s over 80 times faster
# Bigger matrix
A = [StaticParticles(100) for i = 1:30, j = 1:30]
B = similar(A, Float64)
@btime qr($(copy(A)))
  1.823 ms (99 allocations: 802.63 KiB)
@btime map(_-&gt;qr($B), 1:100);
  75.068 ms (403 allocations: 2.11 MiB)
# 40 times faster</code></pre><p><code>StaticParticles</code> allocate much less memory than regular <code>Particles</code>, but are more stressful for the compiler to handle.</p><h1><a class="nav-anchor" id="Constructors-1" href="#Constructors-1">Constructors</a></h1><p>The most basic constructor of <code>Particles</code> acts more or less like <code>randn(N)</code>, i.e., it creates a particle cloud with distribution <code>Normal(0,1)</code>. To create a particle cloud with distribution <code>Normal(μ,σ)</code>, you can call <code>μ + σ*Particles(N)</code>, or <code>Particles(N, Normal(μ,σ))</code>. This last constructor works with any distribution from which one can sample. One can also call (<code>Particles/StaticParticles</code>)</p><ul><li><code>Particles(v::Vector)</code> pre-sampled particles</li><li><code>Particles(N = 500, d::Distribution = Normal(0,1))</code> samples <code>N</code> particles from the distribution <code>d</code>.</li><li>The ± operator (<code>\pm</code>) (similar to <a href="https://github.com/JuliaPhysics/Measurements.jl">Measurements.jl</a>). We have <code>μ ± σ = μ + σ*Particles(DEFAUL_NUM_PARTICLES)</code>, where the global constant <code>DEFAUL_NUM_PARTICLES = 500</code>. You can change this if you would like, or simply define your own <code>±</code> operator like <code>±(μ,σ) = μ + σ*Particles(my_default_number, my_default_distribution)</code>. The upside-down operator ∓ (<code>\mp</code>) instead creates a <code>StaticParticles(100)</code>.</li><li>The <code>..</code> binary infix operator creates uniformly sampled particles, e.g., <code>2..3 = Particles(Uniform(2,3))</code></li></ul><p><strong>Common univariate distributions are sampled systematically</strong>, meaning that a single random number is drawn and used to seed the sample. This will reduce the variance of the sample. If this is not desired, call <code>Particles(N, [d]; systematic=false)</code> The systematic sample can maintain its originally sorted order by calling <code>Particles(N, permute=false)</code>, but the default is to permute the sample so as to not have different <code>Particles</code> correlate strongly with each other.</p><p>Construction of <code>Particles</code> as <a href="https://en.wikipedia.org/wiki/Unscented_transform#Sigma_points">sigma points</a> or by <a href="https://en.wikipedia.org/wiki/Latin_hypercube_sampling">latin hypercube sampling</a> is detailed <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl#sigma-points">below</a>.</p><h1><a class="nav-anchor" id="Multivariate-particles-1" href="#Multivariate-particles-1">Multivariate particles</a></h1><p>The constructors can be called with multivariate distributions, returning <code>v::Vector{Particle}</code> where particles are sampled from the desired multivariate distribution. Once <code>v</code> is propagated through a function <code>v2 = f(v)</code>, the results can be analyzed by, e.g., asking for <code>mean(v2)</code> and <code>cov(v2)</code>, or by fitting a multivariate distribution, e.g., <code>MvNormal(v2)</code>.</p><p>A <code>v::Vector{Particle}</code> can be converted into a <code>Matrix</code> by calling <code>Matrix(v)</code> and this will have a size of <code>N × dim</code>. ~~You can also index into <code>v</code> like it was already a matrix.~~(<a href="https://discourse.julialang.org/t/show-for-vector-type-that-defines-matrix-getindex/23732/2?u=baggepinnen">This was a bad idea</a>)</p><p>Broadcasting the ±/∓ operators works as you would expect, <code>zeros(3) .± 1</code> gives you a three-vector of <em>independent</em> particles, so does <code>zeros(3) .+ Particles.(N)</code>.</p><p>Independent multivariate systematic samples can be created using the function <code>outer_product</code> or the non-exported operator ⊗ (<code>\otimes</code>).</p><h3><a class="nav-anchor" id="Examples-1" href="#Examples-1">Examples</a></h3><p>The following example creates a vector of two <code>Particles</code>. Since they were created independently of each other, they are independent and uncorrelated and have the covariance matrix <code>Σ = Diagonal([1², 2²])</code>. The linear transform with the matrix <code>A</code> should in theory change this covariance matrix to <code>AΣAᵀ</code>, which we can verify be asking for the covariance matrix of the output particles.</p><pre><code class="language-julia">julia&gt; p = [1 ± 1, 5 ± 2]
2-element Array{Particles{Float64,500},1}:
 1.0 ± 1.0
 5.0 ± 2.0

julia&gt; A = randn(2,2)
2×2 Array{Float64,2}:
 -1.80898  -1.24566
  1.41308   0.196504

julia&gt; y = A*p
2-element Array{Particles{Float64,500},1}:
 -8.04 ± 3.1
  2.4 ± 1.5

julia&gt; cov(y)
2×2 Array{Float64,2}:
  9.61166  -3.59812
 -3.59812   2.16701

julia&gt; A*Diagonal([1^2, 2^2])*A&#39;
2×2 Array{Float64,2}:
  9.4791   -3.53535
 -3.53535   2.15126</code></pre><p>To create particles that exhibit a known covariance/correlation, use the appropriate constructor, e.g.,</p><pre><code class="language-julia">julia&gt; p = Particles(10000, MvLogNormal(MvNormal([2, 1],[2. 1;1 3])))
2-element Array{Particles{Float64,10000},1}:
 19.3 ± 48.0
 11.9 ± 43.0

julia&gt; cov(log.(p))
2×2 Array{Float64,2}:
 1.96672  1.0016
 1.0016   2.98605

julia&gt; mean(log.(p))
2-element Array{Float64,1}:
 1.985378409751101
 1.000702538699887</code></pre><h1><a class="nav-anchor" id="Sigma-points-1" href="#Sigma-points-1">Sigma points</a></h1><p>The <a href="https://en.wikipedia.org/wiki/Unscented_transform#Sigma_points">unscented transform</a> uses a small number of points called <em>sigma points</em> to propagate the first and second moments of a probability density. We provide a function <code>sigmapoints(μ, Σ)</code> that creates a <code>Matrix</code> of <code>2n+1</code> sigma points, where <code>n</code> is the dimension. This can be used to initialize any kind of <code>AbstractParticles</code>, e.g.:</p><pre><code class="language-julia">julia&gt; m = [1,2]

julia&gt; Σ = [3. 1; 1 4]

julia&gt; p = StaticParticles(sigmapoints(m,Σ))
2-element Array{StaticParticles{Float64,5},1}:
 1.0 ± 1.7 # 2n+1 = 5 particles
 2.0 ± 2.0

julia&gt; cov(p) ≈ Σ
true

julia&gt; mean(p) ≈ m
true</code></pre><p><code>sigmapoints</code> also accepts a <code>Normal/MvNormal</code> object as input. <em>Caveat:</em> If you are creating several one-dimensional uncertain values using sigmaopints independently, they will be strongly correlated. Use the multidimensional constructor! Example:</p><pre><code class="language-julia">p = StaticParticles(sigmapoints(1, 0.1^2))               # Wrong!
ζ = StaticParticles(sigmapoints(0.3, 0.1^2))             # Wrong!
ω = StaticParticles(sigmapoints(1, 0.1^2))               # Wrong!

p,ζ,ω = StaticParticles(sigmapoints([1, 0.3, 1], 0.1^2)) # Correct</code></pre><h1><a class="nav-anchor" id="Latin-hypercube-sampling-1" href="#Latin-hypercube-sampling-1">Latin hypercube sampling</a></h1><p>We do not provide functionality for <a href="https://en.wikipedia.org/wiki/Latin_hypercube_sampling">latin hypercube sampling</a>, rather, we show how to use the package <a href="https://github.com/MrUrq/LatinHypercubeSampling.jl">LatinHypercubeSampling.jl</a> to initialize particles.</p><pre><code class="language-julia"># import Pkg; Pkg.add(&quot;LatinHypercubeSampling&quot;)
using MonteCarloMeasurements, LatinHypercubeSampling
ndims  = 2
N      = 100  # Number of particles
ngen   = 2000 # How long to run optimization
X, fit = LHCoptim(N,ndims,ngen)
m, Σ   = [1,2], [2 1; 1 4] # Desired mean and covariance
particle_matrix = transform_moments(X,m,Σ)
p      = Particles(particle_matrix) # These are our LHS particles with correct moments
plot(scatter(eachcol(particles)..., title=&quot;Sample&quot;), plot(fit, title=&quot;Fitness vs. iteration&quot;))

julia&gt; mean(p)
2-element Array{Float64,1}:
 1.0
 2.0

julia&gt; cov(p)
2×2 Array{Float64,2}:
 2.0  1.0
 1.0  4.0</code></pre><p>Latin hypercube sampling creates an approximately uniform sample in <code>ndims</code> dimensions. The applied transformation gives the particles the desired mean and covariance. <em>Caveat:</em> Unfortunately, endowing the sampled latin hypercube with a desired <em>non-diagonal</em> covariance matrix destroys the latin properties for all dimensions but the first. This is less of a problem for diagonal covariance matrices provided that the latin optimizer was run sufficiently long.</p><p>The statistics of the sample can be visualized:</p><pre><code class="language-julia">using StatsPlots
corrplot(particles)
plot(density(p[1]), density(p[2]))</code></pre><p>see also <code>examples/lhs.jl</code>.</p><h1><a class="nav-anchor" id="Plotting-1" href="#Plotting-1">Plotting</a></h1><p>An instance of <code>p::Particles</code> can be plotted using <code>plot(p)</code>, that creates a histogram by default. If <a href="https://github.com/JuliaPlots/StatsPlots.jl"><code>StatsPlots.jl</code></a> is available, one can call <code>density(p)</code> to get a slightly different visualization. Vectors of particles can be plotted using one of</p><ul><li><code>errorbarplot(x,y,[q=0.025])</code>: <code>q</code> determines the quantiles, set to <code>0</code> for max/min. You can also specify both bounds, e.g., <code>q = (0.01, 0.99)</code>.</li><li><code>mcplot(x,y)</code>: Plots all trajectories</li><li><code>ribbonplot(x,y,[q=0.025])</code>: Plots with shaded area from quantile <code>q</code> to <code>1-q</code>. You can also specify both bounds, e.g., <code>q = (0.01, 0.99)</code>.</li></ul><p>Below is an example using <a href="https://github.com/JuliaControl/ControlSystems.jl">ControlSystems.jl</a></p><pre><code class="language-julia">using ControlSystems, MonteCarloMeasurements, StatsPlots

p = 1 ± 0.1
ζ = 0.3 ± 0.1
ω = 1 ± 0.1
G = tf([p*ω], [1, 2ζ*ω, ω^2]) # Transfer function with uncertain parameters

dc = dcgain(G)[]
# Part500(1.01 ± 0.147)
density(dc, title=&quot;Probability density of DC-gain&quot;)</code></pre><p><img src="figs/dens.svg" alt="A density"/></p><pre><code class="language-julia">w = exp10.(LinRange(-1,1,200)) # Frequency vector
mag, phase = bode(G,w) .|&gt; vec

errorbarplot(w,mag, yscale=:log10, xscale=:log10)</code></pre><p><img src="figs/errorbar.svg" alt="A bodeplot with errorbars"/></p><pre><code class="language-julia">mcplot(w,mag, yscale=:log10, xscale=:log10, alpha=0.2)</code></pre><p><img src="figs/mc.svg" alt="A bodeplot with lots of lines"/></p><pre><code class="language-julia">ribbonplot(w,mag, yscale=:log10, xscale=:log10, alpha=0.2)</code></pre><p><img src="figs/rib.svg" alt="A bodeplot with a ribbon"/></p><h1><a class="nav-anchor" id="Differential-Equations-1" href="#Differential-Equations-1">Differential Equations</a></h1><p><a href="http://tutorials.juliadiffeq.org/html/type_handling/02-uncertainties.html">The tutorial</a> for solving differential equations using <code>Measurement</code> works for <code>Particles</code> as well. A word of caution for actually using Measurements.jl in this example: while solving the pendulum on short time scales, linear uncertainty propagation works well, as evidenced by the below simulation of a pendulum with uncertain properties</p><pre><code class="language-julia">function sim(±, tspan, plotfun=plot!; kwargs...)
    g = 9.79 ± 0.02; # Gravitational constant
    L = 1.00 ± 0.01; # Length of the pendulum
    u₀ = [0 ± 0, π / 3 ± 0.02] # Initial speed and initial angle

    #Define the problem
    function simplependulum(du,u,p,t)
        θ  = u[1]
        dθ = u[2]
        du[1] = dθ
        du[2] = -(g/L) * sin(θ)
    end

    prob = ODEProblem(simplependulum, u₀, tspan)
    sol = solve(prob, Tsit5(), reltol = 1e-6)

    plotfun(sol.t, getindex.(sol.u, 2); kwargs...)
end

tspan = (0.0, 5)
plot()
sim(Measurements.:±, tspan, label = &quot;Linear&quot;, xlims=(tspan[2]-5,tspan[2]))
sim(MonteCarloMeasurements.:±, tspan, label = &quot;MonteCarlo&quot;, xlims=(tspan[2]-5,tspan[2]))</code></pre><p><img src="figs/short_timescale.svg" alt="window"/></p><p>The mean and errorbars for both Measurements and MonteCarloMeasurements line up perfectly when integrating over 5 seconds.</p><p>However, the uncertainty in the pendulum coefficients implies that the frequency of the pendulum oscillation is uncertain, when solving on longer time scales, this should result in the phase being completely unknown, something linear uncertainty propagation does not handle</p><pre><code class="language-julia">tspan = (0.0, 200)
plot()
sim(Measurements.:±, tspan, label = &quot;Linear&quot;, xlims=(tspan[2]-5,tspan[2]))
sim(MonteCarloMeasurements.:±, tspan, label = &quot;MonteCarlo&quot;, xlims=(tspan[2]-5,tspan[2]))</code></pre><p><img src="figs/long_timescale.svg" alt="window"/></p><p>We now integrated over 200 seconds and look at the last 5 seconds. This result maybe looks a bit confusing, the linear uncertainty propagation is very sure about the amplitude at certain points but not at others, whereas the Monte-Carlo approach is completely unsure. Furthermore, the linear approach thinks that the amplitude at some points is actually much higher than the starting amplitude, implying that energy somehow has been added to the system! The picture might become a bit more clear by plotting the individual trajectories of the particles</p><pre><code class="language-julia">plot()
sim(Measurements.:±, tspan, label = &quot;Linear&quot;, xlims=(tspan[2]-5,tspan[2]), l=(5,))
sim(MonteCarloMeasurements.:∓, tspan, mcplot!, label = &quot;&quot;, xlims=(tspan[2]-5,tspan[2]), l=(:black,0.1))</code></pre><p><img src="figs/long_timescale_mc.svg" alt="window"/></p><p>It now becomes clear that each trajectory has a constant amplitude (although individual trajectories amplitudes vary slightly due to the uncertainty in the initial angle), but the phase is all mixed up due to the slightly different frequencies!</p><p>These problems grow with increasing uncertainty and increasing integration time. In fact, the uncertainty reported by Measurements.jl goes to infinity as the integration time does the same.</p><p>Of course, the added accuracy from using MonteCarloMeasurements does not come for free, as it costs some additional computation. We have the following timings for integrating the above system 100 seconds using three different uncertainty representations</p><pre><code class="language-julia">Measurements.:±             14.596 ms  (729431 allocations: 32.43 MiB)   # Measurements.Measurement
MonteCarloMeasurements.:∓   25.115 ms  (25788 allocations: 24.68 MiB)    # 100 StaticParticles
MonteCarloMeasurements.:±   345.730 ms (696212 allocations: 838.50 MiB)  # 500 Particles</code></pre><h1><a class="nav-anchor" id="Limitations-1" href="#Limitations-1">Limitations</a></h1><p>One major limitation is functions that contain control flow, where the branch is decided by an uncertain value. Consider the following case</p><pre><code class="language-julia">function negsquare(x)
    x &gt; 0 ? x^2 : -x^2
end
p = 0 ± 1</code></pre><p>Ideally, half of the particles should turn out negative and half positive when applying <code>negsquare(p)</code>. However, this will not happen as the <code>x &gt; 0</code> is not defined for uncertain values. To circumvent this, define <code>negsquare</code> as a primitive using <code>register_primitive</code> described below. Particles will then be propagated one by one through the entire function <code>negsquare</code>. Common such functions from <code>Base</code>, such as <code>max/min</code> etc. are already registered.</p><p>Sometimes, defining a primitive function can be difficult, such as when the uncertain parameters are baked into some object. In such cases, we can call the function <code>unsafe_comparisons(true)</code>, which defines all comparison operators for uncertain values to compare using the <code>mean</code>. Note however that this enabling this is somewhat <em>unsafe</em> as this corresponds to a fallback to linear uncertainty propagation, why it&#39;s turned off by default. We also provide the macro <code>@unsafe ex</code> to enable mean comparisons only locally in the expression <code>ex</code>.</p><p>In some cases, defining a primitive is not possible but allowing unsafe comparisons are not acceptable. One such case is functions that internally calculate eigenvalues of uncertain matrices. The eigenvalue calculation makes use of comparison operators. If the uncertainty is large, eigenvalues might change place in the sorted list of returned eigenvalues, completely ruining downstream computations. For this we recommend, in order of preference</p><ol><li>Use <code>@bymap</code> defined <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl#monte-carlo-simulation-by-mappmap">below</a>. Applicable if all uncertain values appears as arguments to your entry function.</li><li>Create a <code>Workspace</code> object and call it using your entry function. Applicable if uncertain parameters appear nested in an object that is an argument to your entry function:</li></ol><pre><code class="language-julia"># desired computation: y = f(obj), obj contains uncertain parameters inside
y = with_workspace(f, obj)
# or equivalently
w = Workspace(f,obj) # This is somewhat expensive and can be reused
use_invokelatest = true # Set this to false to gain 0.1-1 ms, at the expense of world-age problems if w is created and used in the same function.
w(obj, use_invokelatest)</code></pre><p>This interface is so far not tested very well and may throw strange errors. Some care has been taken to make error messages informative. Internally, a <code>w::Workspace</code> object is created that tries to automatically construct an object identical to <code>obj</code>, but where all uncertain parameters are replaced by conventional <code>Real</code>. If the heuristics used fail, an error message is displayed detailing which method you need to implement to make it work. When called, <code>w</code> populates the internal buffer object with particle <code>i</code>, calls <code>f</code> using a <code>Particle</code>-free <code>obj</code> and stores the result in an output object at particle index  <code>i</code>. This is done for <code>i ∈ 1:N</code> after which the output is returned. Some caveats include: <code>Workspace</code> must not be created or used inside a <code>@generated</code> function.</p><h1><a class="nav-anchor" id="Overloading-a-new-function-1" href="#Overloading-a-new-function-1">Overloading a new function</a></h1><p>If a method for <code>Particles</code> is not implemented for your function <code>yourfunc</code>, the pattern looks like this</p><pre><code class="language-julia">register_primitive(yourfunc)</code></pre><p>This defines both a one-argument method and a multi-arg method for both <code>Particles</code> and <code>StaticParticles</code>. If you only want to define one of these, see <code>register_primitive_single</code>/<code>register_primitive_multi</code>. If the function is from base or stdlib, you can just add it to the appropriate list in the source and submit a PR :)</p><h1><a class="nav-anchor" id="Monte-Carlo-simulation-by-map/pmap-1" href="#Monte-Carlo-simulation-by-map/pmap-1">Monte-Carlo simulation by <code>map/pmap</code></a></h1><p>Some functions will not work when the input arguments are of type <code>Particles</code>. For this kind of function, we provide a fallback onto a traditional <code>map(f,p.particles)</code>. The only thing you need to do is to decorate the function call with the macro <code>@bymap</code> like so:</p><pre><code class="language-julia">f(x) = 3x^2
p = 1 ± 0.1
r = @bymap f(p)</code></pre><p>We further provide the macro <code>@bypmap</code> which does exactly the same thing, but with a <code>pmap</code> (parallel map) instead, allowing you to run several invocations of <code>f</code> in a distributed fashion.</p><p>These macros will map the function <code>f</code> over each element of <code>p::Particles{T,N}</code>, such that <code>f</code> is only called with arguments of type <code>T</code>, e.g., <code>Float64</code>. This handles arguments that are multivaiate particles <code>&lt;: Vector{&lt;:AbstractParticles}</code> as well.</p><p>These macros will typically be slower than calling <code>f(p)</code>. If <code>f</code> is very expensive, <code>@bypmap</code> might prove prove faster than calling <code>f</code> with <code>p</code>, it&#39;s worth a try. The usual caveats for distributed computing applies, all code must be loaded on all workers etc.</p><h1><a class="nav-anchor" id="ℝⁿ-ℝⁿ-functions-1" href="#ℝⁿ-ℝⁿ-functions-1">ℝⁿ → ℝⁿ functions</a></h1><p>These functions do not work with <code>Particles</code> out of the box. Special cases are currently implemented for</p><ul><li><code>exp : ℝ(n×n) → ℝ(n×n)</code>   matrix exponential</li><li><code>log : ℝ(n×n) → C(n×n)</code>   matrix logarithm</li><li><code>eigvals : ℝ(n×n) → C(n)</code> <strong>warning</strong>: eigenvalues are sorted, when two eigenvalues cross, this function is nondifferentiable. Eigenvalues can thus appear to have dramatically widened distributions. Make sure you interpret the result of this call in the right way.</li></ul><p>The function <code>ℝⁿ2ℝⁿ_function(f::Function, p::AbstractArray{T})</code> applies <code>f : ℝⁿ → ℝⁿ</code> to an array of particles.</p><h1><a class="nav-anchor" id="ℂ-ℂ-functions-1" href="#ℂ-ℂ-functions-1">ℂ → ℂ functions</a></h1><p>These functions do not work with <code>Particles</code> out of the box. Special cases are currently implemented for</p><ul><li><code>sqrt</code>, <code>exp</code>, <code>sin</code>, <code>cos</code></li></ul><p>We also provide in-place versions of the above functions, e.g.,</p><ul><li><code>sqrt!(out, p)</code>, <code>exp!(out, p)</code>, <code>sin!(out, p)</code>, <code>cos!(out, p)</code></li></ul><p>The function <code>ℂ2ℂ_function(f::Function, z)</code> (<code>ℂ2ℂ_function!(f::Function, out, z)</code>) applies <code>f : ℂ → ℂ</code> to <code>z::Complex{&lt;:AbstractParticles}</code>.</p><h1><a class="nav-anchor" id="Weighted-particles-1" href="#Weighted-particles-1">Weighted particles</a></h1><p>The type <code>WeightedParticles</code> contains an additional field <code>logweights</code>. You may modify this field as you see fit, e.g.</p><pre><code class="language-julia">reweight(p,y) = (p.logweights .+= logpdf.(Normal(0,1), y .- p.particles))</code></pre><p>where <code>y</code> would be some measurement. After this you can resample the particles using <code>resample!(p)</code>. This performs a systematic resample with replacement, where each particle is sampled proportionally to <code>exp.(logweights)</code>.</p><h1><a class="nav-anchor" id="When-to-use-what?-1" href="#When-to-use-what?-1">When to use what?</a></h1><table><tr><th style="text-align: right">Situation</th><th style="text-align: right">Action</th></tr><tr><td style="text-align: right">Linear functions</td><td style="text-align: right">Use linear uncertainty propagation, i.e., Measurements.jl</td></tr><tr><td style="text-align: right">Highly nonlinear/discountinuous functions</td><td style="text-align: right">Use MonteCarloMeasurements</td></tr><tr><td style="text-align: right">Correlated quantities</td><td style="text-align: right">Use MonteCarloMeasurements</td></tr><tr><td style="text-align: right">Large uncertainties in input</td><td style="text-align: right">Use MonteCarloMeasurements</td></tr><tr><td style="text-align: right">Small uncertainties in input in relation to the curvature of the function</td><td style="text-align: right">Use Measurements</td></tr><tr><td style="text-align: right">Interested in low probability events / extremas</td><td style="text-align: right">Use MonteCarloMeasurements</td></tr><tr><td style="text-align: right">Limited computational budget</td><td style="text-align: right">Use Measurements or <code>StaticParticles</code> with  <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl#sigma-points"><code>sigmapoints</code></a>. See benchmark below.</td></tr><tr><td style="text-align: right">Non-Gaussian input distribution</td><td style="text-align: right">Use MonteCarloMeasurements</td></tr><tr><td style="text-align: right">Calculate tail integrals accurately</td><td style="text-align: right">This requires some form of <a href="https://en.wikipedia.org/wiki/Importance_sampling#Application_to_simulation">importance sampling</a>, not yet fully supported</td></tr></table><p>Due to <a href="https://en.wikipedia.org/wiki/Jensen%27s_inequality">Jensen&#39;s inequality</a>, linear uncertainty propagation will always underestimate the mean of nonlinear convex functions and overestimate the mean of concave functions. From wikipedia</p><blockquote><p>In its simplest form the inequality states that the convex transformation of a mean is less than or equal to the mean applied after convex transformation; it is a simple corollary that the opposite is true of concave transformations.</p></blockquote><p>Linear uncertainty propagation does thus not allow you to upperbound/lowerbound the output uncertainty of a convex/concave function, and will be conservative in the reverse case.</p><p>The benchmark results below come from <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/controlsystems.jl"><code>examples/controlsystems.jl</code></a> The benchmark consists of calculating the Bode curves for a linear system with uncertain parameters</p><pre><code class="language-julia">w  = exp10.(LinRange(-1,1,200)) # Frequency vector
p  = 1 ± 0.1
ζ  = 0.3 ± 0.1
ω  = 1 ± 0.1
G  = tf([p*ω], [1, 2ζ*ω, ω^2])
t1 = @belapsed bode($G,$w)
   ⋮</code></pre><table><tr><th style="text-align: right">Benchmark</th><th style="text-align: right">Result</th></tr><tr><td style="text-align: right">Time with 500 particles</td><td style="text-align: right">2.6953ms</td></tr><tr><td style="text-align: right">Time with regular floating point</td><td style="text-align: right">0.1174ms</td></tr><tr><td style="text-align: right">Time with Measurements</td><td style="text-align: right">0.1957ms</td></tr><tr><td style="text-align: right">Time with 100 static part.</td><td style="text-align: right">0.5641ms</td></tr><tr><td style="text-align: right">Time with static sigmapoints.</td><td style="text-align: right">0.2371ms</td></tr><tr><td style="text-align: right">500×floating point time</td><td style="text-align: right">58.6930ms</td></tr><tr><td style="text-align: right">Speedup factor vs. Manual</td><td style="text-align: right">21.8x</td></tr><tr><td style="text-align: right">Slowdown factor vs. Measurements</td><td style="text-align: right">13.8x</td></tr><tr><td style="text-align: right">Slowdown static vs. Measurements</td><td style="text-align: right">2.9x</td></tr><tr><td style="text-align: right">Slowdown sigma vs. Measurements</td><td style="text-align: right">1.2x</td></tr></table><h2><a class="nav-anchor" id="Comparison-to-nonlinear-filtering-1" href="#Comparison-to-nonlinear-filtering-1">Comparison to nonlinear filtering</a></h2><p>The table below compares methods for uncertainty propagation with their parallel in nonlinear filtering.</p><table><tr><th style="text-align: right">Uncertainty propagation</th><th style="text-align: right">Dynamic filtering</th><th style="text-align: right">Method</th></tr><tr><td style="text-align: right">Measurements.jl</td><td style="text-align: right">Extended Kalman filter</td><td style="text-align: right">Linearization</td></tr><tr><td style="text-align: right"><code>Particles(sigmapoints)</code></td><td style="text-align: right">Unscented Kalman Filter</td><td style="text-align: right">Unscented transform</td></tr><tr><td style="text-align: right"><code>Particles</code></td><td style="text-align: right"><a href="https://github.com/baggepinnen/LowLevelParticleFilters.jl">Particle Filter</a></td><td style="text-align: right">Monte Carlo (sampling)</td></tr></table><h1><a class="nav-anchor" id="Examples-2" href="#Examples-2">Examples</a></h1><h2><a class="nav-anchor" id="[Control-systems](https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/controlsystems.jl)-1" href="#[Control-systems](https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/controlsystems.jl)-1"><a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/controlsystems.jl">Control systems</a></a></h2><p>This example shows how to simulate control systems (using <a href="https://github.com/JuliaControl/ControlSystems.jl">ControlSystems.jl</a>) with uncertain parameters. We calculate and display Bode diagrams, Nyquist diagrams and time-domain responses. We also illustrate how the package <a href="https://github.com/baggepinnen/ControlSystemIdentification.jl">ControlSystemIdentification.jl</a> interacts with MonteCarloMeasurements to facilitate the creation and analysis of uncertain systems.</p><p>We also perform some limited benchmarks.</p><h2><a class="nav-anchor" id="[Latin-Hypercube-Sampling](https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/lhs.jl)-1" href="#[Latin-Hypercube-Sampling](https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/lhs.jl)-1"><a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/lhs.jl">Latin Hypercube Sampling</a></a></h2><p>We show how to initialize particles with LHS and how to make sure the sample gets the desired moments. We also visualize the statistics of the sample.</p><h2><a class="nav-anchor" id="[How-MC-uncertainty-propagation-works](https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/transformed_densities.jl)-1" href="#[How-MC-uncertainty-propagation-works](https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/transformed_densities.jl)-1"><a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/transformed_densities.jl">How MC uncertainty propagation works</a></a></h2><p>We produce the first figure in this readme and explain in visual detail how different forms of uncertainty propagation propagates a probability distribution through a nonlinear function.</p><h2><a class="nav-anchor" id="[Robust-probabilistic-optimization](https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/robust_controller_opt.jl)-1" href="#[Robust-probabilistic-optimization](https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/robust_controller_opt.jl)-1"><a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/robust_controller_opt.jl">Robust probabilistic optimization</a></a></h2><p>Here, we use MonteCarloMeasurements to perform <a href="https://en.wikipedia.org/wiki/Robust_optimization">robust optimization</a>. With robust and probabilistic, we mean that we place some kind of bound on a quantile of an uncertain value, or otherwise make use of the probability distribution of some value that depend on the optimized parameters.</p><p>The application we consider is optimization of a PID controller. Normally, we are interested in controller performance and robustness against uncertainty. The robustness is often introduced by placing an upper bound on the, so called, sensitivity function. When the system to be controlled is parameterized by <code>Particles</code>, we can penalize both variance in the performance measure as well as the 90:th quantile of the maximum of the sensitivity function. This example illustrates how easy it is to incorporate probabilistic constrains or cost functions in an optimization problem using <code>Particles</code>.</p><h2><a class="nav-anchor" id="[Autodiff-and-Robust-optimization](https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/autodiff_robust_opt.jl)-1" href="#[Autodiff-and-Robust-optimization](https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/autodiff_robust_opt.jl)-1"><a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/master/examples/autodiff_robust_opt.jl">Autodiff and Robust optimization</a></a></h2><p>Another example using MonteCarloMeasurements to perform <a href="https://en.wikipedia.org/wiki/Robust_optimization">robust optimization</a>, this time with automatic differentiation. We use Optim.jl to solve a linear program with probabilistic constraints using 4 different methods, two gradient free, one first-order and one second-order method. We demonstrate calculation of gradients of uncertain functions with uncertain inputs using both Zygote.jl and ForwardDiff.jl.</p><h2><a class="nav-anchor" id="Monte-Carlo-sampling-properties-1" href="#Monte-Carlo-sampling-properties-1">Monte-Carlo sampling properties</a></h2><p>The variance introduced by Monte-Carlo sampling has some fortunate and some unfortunate properties. It decreases as 1/N, where N is the number of particles/samples. This unfortunately means that to get half the standard deviation in your estimate, you need to quadruple the number of particles. On the other hand, this variance does not depend on the dimension of the space, which is very fortunate.</p><p>In this package, we perform <a href="https://arxiv.org/pdf/cs/0507025.pdf"><em>systematic sampling</em></a> whenever possible. This approach exhibits lower variance than standard random sampling. Below, we investigate the variance of the mean estimator of a random sample from the normal distribution. The variance of the estimate of the mean is known to decrease as 1/N</p><pre><code class="language-julia">default(l=(3,))
N = 1000
svec = round.(Int, exp10.(LinRange(1, 3, 50)))
vars = map(svec) do i
  var(mean(randn(i)) for _ in 1:1000)
end
plot(svec, vars, yscale=:log10, xscale=:log10, lab=&quot;Random sampling&quot;, xlabel=&quot;\$N\$&quot;, ylabel=&quot;Variance&quot;)
plot!(svec, N-&gt;1/N, lab=&quot;\$1/N\$&quot;, l=(:dash,))
vars = map(svec) do i
  var(mean(systematic_sample(i)) for _ in 1:1000)
end
plot!(svec, vars, lab=&quot;Systematic sampling&quot;)
plot!(svec, N-&gt;1/N^2, lab=&quot;\$1/N^2\$&quot;, l=(:dash,))</code></pre><p><img src="figs/variance.svg" alt="variance plot"/></p><p>As we can see, the variance of the standard random sampling decreases as expected. We also see that the variance for the systematic sample is considerably lower, and also scales as (almost) 1/N².</p><p>A simplified implementation of the systematic sampler is given below</p><pre><code class="language-julia">function systematic_sample(N, d=Normal(0,1))
    e   = rand()/N
    y   = e:1/N:1
    map(x-&gt;quantile(d,x), y)
end</code></pre><p>~~As we can see, a single random number is generated to seed the entire sample.~~ (This has been changed to <code>e=0.5/N</code> to have a correct mean.) The samples are then drawn deterministically from the quantile function of the distribution.</p><h2><a class="nav-anchor" id="Variational-inference-1" href="#Variational-inference-1">Variational inference</a></h2><p>See blog post by <a href="https://github.com/cscherrer">@cscherrer</a> for an example of variational inference using <code>Particles</code></p><p>https://cscherrer.github.io/post/variational-importance-sampling/</p><h1><a class="nav-anchor" id="Exported-functions-and-types-1" href="#Exported-functions-and-types-1">Exported functions and types</a></h1><h2><a class="nav-anchor" id="Index-1" href="#Index-1">Index</a></h2><ul><li><a href="#MonteCarloMeasurements.Particles"><code>MonteCarloMeasurements.Particles</code></a></li><li><a href="#MonteCarloMeasurements.StaticParticles"><code>MonteCarloMeasurements.StaticParticles</code></a></li><li><a href="#MonteCarloMeasurements.WeightedParticles"><code>MonteCarloMeasurements.WeightedParticles</code></a></li><li><a href="#MonteCarloMeasurements.Workspace"><code>MonteCarloMeasurements.Workspace</code></a></li><li><a href="#MonteCarloMeasurements.Workspace-Tuple{Any,Any}"><code>MonteCarloMeasurements.Workspace</code></a></li><li><a href="#Base.:≈-Tuple{AbstractParticles,AbstractParticles}"><code>Base.:≈</code></a></li><li><a href="#Base.:≉-Tuple{AbstractParticles,AbstractParticles}"><code>Base.:≉</code></a></li><li><a href="#MonteCarloMeasurements.:±-Tuple{Real,Any}"><code>MonteCarloMeasurements.:±</code></a></li><li><a href="#MonteCarloMeasurements.bootstrap-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractParticles"><code>MonteCarloMeasurements.bootstrap</code></a></li><li><a href="#MonteCarloMeasurements.errorbarplot"><code>MonteCarloMeasurements.errorbarplot</code></a></li><li><a href="#MonteCarloMeasurements.has_particles-Tuple{Any}"><code>MonteCarloMeasurements.has_particles</code></a></li><li><a href="#MonteCarloMeasurements.mcplot"><code>MonteCarloMeasurements.mcplot</code></a></li><li><a href="#MonteCarloMeasurements.mean_object-Tuple{AbstractParticles}"><code>MonteCarloMeasurements.mean_object</code></a></li><li><a href="#MonteCarloMeasurements.outer_product"><code>MonteCarloMeasurements.outer_product</code></a></li><li><a href="#MonteCarloMeasurements.resample!-Tuple{WeightedParticles}"><code>MonteCarloMeasurements.resample!</code></a></li><li><a href="#MonteCarloMeasurements.ribbonplot"><code>MonteCarloMeasurements.ribbonplot</code></a></li><li><a href="#MonteCarloMeasurements.set_comparison_function-Tuple{Any}"><code>MonteCarloMeasurements.set_comparison_function</code></a></li><li><a href="#MonteCarloMeasurements.sigmapoints-Tuple{Any,AbstractArray{T,2} where T}"><code>MonteCarloMeasurements.sigmapoints</code></a></li><li><a href="#MonteCarloMeasurements.systematic_sample"><code>MonteCarloMeasurements.systematic_sample</code></a></li><li><a href="#MonteCarloMeasurements.transform_moments-Tuple{Any,Any,Any}"><code>MonteCarloMeasurements.transform_moments</code></a></li><li><a href="#MonteCarloMeasurements.unsafe_comparisons"><code>MonteCarloMeasurements.unsafe_comparisons</code></a></li><li><a href="#MonteCarloMeasurements.wasserstein-Tuple{AbstractParticles,AbstractParticles,Any}"><code>MonteCarloMeasurements.wasserstein</code></a></li><li><a href="#MonteCarloMeasurements.with_workspace-Tuple{Any,Any}"><code>MonteCarloMeasurements.with_workspace</code></a></li><li><a href="#MonteCarloMeasurements.ℂ2ℂ_function-Union{Tuple{T}, Tuple{F}, Tuple{F,Complex{T}}} where T&lt;:AbstractParticles where F"><code>MonteCarloMeasurements.ℂ2ℂ_function</code></a></li><li><a href="#MonteCarloMeasurements.ℝⁿ2ℝⁿ_function-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F,AbstractArray{StaticParticles{T,N},N1} where N1}} where N where T where F"><code>MonteCarloMeasurements.ℝⁿ2ℝⁿ_function</code></a></li><li><a href="#MonteCarloMeasurements.ℝⁿ2ℝⁿ_function-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F,AbstractArray{Particles{T,N},N1} where N1}} where N where T where F"><code>MonteCarloMeasurements.ℝⁿ2ℝⁿ_function</code></a></li><li><a href="#MonteCarloMeasurements.@unsafe-Tuple{Any}"><code>MonteCarloMeasurements.@unsafe</code></a></li></ul><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.Particles" href="#MonteCarloMeasurements.Particles"><code>MonteCarloMeasurements.Particles</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Particles{T, N} &lt;: AbstractParticles{T, N}</code></pre><p>This type represents uncertainty using a cloud of particles.</p><p><strong>Constructors:</strong></p><ul><li><code>Particles()</code></li><li><code>Particles(N::Integer)</code></li><li><code>Particles(d::Distribution)</code></li><li><code>Particles(N::Integer, d::Distribution)</code></li><li><code>Particles(N::Integer, d::Distribution; permute, systematic)</code></li><li><code>Particles(v::Array{T,1} where T)</code></li><li><code>Particles(m::Array{T,2} where T)</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/types.jl#L5-L17">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.StaticParticles" href="#MonteCarloMeasurements.StaticParticles"><code>MonteCarloMeasurements.StaticParticles</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct StaticParticles{T, N} &lt;: AbstractParticles{T, N}</code></pre><p>See <code>?Particles</code> for help. The difference between <code>StaticParticles</code> and <code>Particles</code> is that the <code>StaticParticles</code> store particles in a static vecetor. This makes runtimes much shorter, but compile times longer. See the documentation for some benchmarks.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/types.jl#L22-L26">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.WeightedParticles" href="#MonteCarloMeasurements.WeightedParticles"><code>MonteCarloMeasurements.WeightedParticles</code></a> — <span class="docstring-category">Type</span>.</div><div><div><p>Particles with weights. To weight the particles <code>p</code>, modify the field <code>p.logweights</code>. You can resample the particles using <code>resample!(p)</code>, where each particles is resampled with a probability proportional to its weight.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/types.jl#L31-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.Workspace" href="#MonteCarloMeasurements.Workspace"><code>MonteCarloMeasurements.Workspace</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">struct Workspace{T1, T2, T3, T4, T5, T6}</code></pre><p>DOCSTRING</p><p>#Arguments:</p><ul><li><code>simple_input</code>: Input object <code>f</code> will be called with, does not contain any particles</li><li><code>simple_result</code>: Simple output from <code>f</code> without particles</li><li><code>result</code>: Complete output of <code>f</code> including particles</li><li><code>buffersetter</code>: Helper function to shift data between objects</li><li><code>resultsetter</code>: Helper function to shift data between objects</li><li><code>f</code>: Function to call</li><li><code>N</code>: Number of particles</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/deconstruct.jl#L292-L305">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.Workspace-Tuple{Any,Any}" href="#MonteCarloMeasurements.Workspace-Tuple{Any,Any}"><code>MonteCarloMeasurements.Workspace</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Workspace(f, input)</code></pre><p>Create a <code>Workspace</code> object for inputs of type <code>typeof(input)</code>. Useful if <code>input</code> is a structure with fields of type <code>&lt;: AbstractParticles</code> (can be deeply nested). See also <code>with_workspace</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/deconstruct.jl#L316-L319">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.:±-Tuple{Real,Any}" href="#MonteCarloMeasurements.:±-Tuple{Real,Any}"><code>MonteCarloMeasurements.:±</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">μ ± σ</code></pre><p>Creates 500 <code>Particles</code> with mean <code>μ</code> and std <code>σ</code>. If <code>μ</code> is a vector, the constructor <code>MvNormal</code> is used, and <code>σ</code> is thus treated as std if it&#39;s a scalar, and variances if it&#39;s a matrix or vector.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/particles.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.bootstrap-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractParticles" href="#MonteCarloMeasurements.bootstrap-Union{Tuple{T}, Tuple{T}} where T&lt;:AbstractParticles"><code>MonteCarloMeasurements.bootstrap</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bootstrap(p::Particles)</code></pre><p>Return Particles resampled with replacement.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/resampling.jl#L69-L73">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.errorbarplot" href="#MonteCarloMeasurements.errorbarplot"><code>MonteCarloMeasurements.errorbarplot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>errorbarplot(x,y,[q=0.025])</p><p>Plots a vector of particles with error bars at quantile <code>q</code>. If <code>q::Tuple</code>, then you can specify both lower and upper quantile, e.g., <code>(0.01, 0.99)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/plotting.jl#L62-L67">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.has_particles-Tuple{Any}" href="#MonteCarloMeasurements.has_particles-Tuple{Any}"><code>MonteCarloMeasurements.has_particles</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">has_particles(P)</code></pre><p>Determine whether or no the object <code>P</code> has some kind of particles inside it. This function examins fields of <code>P</code> recursively and looks inside arrays etc.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/deconstruct.jl#L1-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.mcplot" href="#MonteCarloMeasurements.mcplot"><code>MonteCarloMeasurements.mcplot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>mcplot(x,y,[q=0.025])</p><p>Plots all trajectories represented by a vector of particles</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/plotting.jl#L70-L74">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.mean_object-Tuple{AbstractParticles}" href="#MonteCarloMeasurements.mean_object-Tuple{AbstractParticles}"><code>MonteCarloMeasurements.mean_object</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">mean_object(x)</code></pre><p>Returns an object similar to <code>x</code>, but where all internal instances of <code>Particles</code> are replaced with their mean. The generalization of this function is <code>replace_particles</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/deconstruct.jl#L89-L92">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.outer_product" href="#MonteCarloMeasurements.outer_product"><code>MonteCarloMeasurements.outer_product</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">p = outer_product(dists::Vector{&lt;:Distribution}, N=100_000)</code></pre><p>Creates a multivariate systematic sample where each dimension is sampled according to the corresponding univariate distribution in <code>dists</code>. Returns <code>p::Vector{Particles}</code> where each Particles has a length approximately equal to <code>N</code>. The particles form the outer product between <code>d</code> systematically sampled vectors with length given by the d:th root of N, where <code>d</code> is the length of <code>dists</code>, All particles will be independent and have marginal distributions given by <code>dists</code>.</p><p>See also <code>MonteCarloMeasurements.⊗</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/particles.jl#L21-L28">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.resample!-Tuple{WeightedParticles}" href="#MonteCarloMeasurements.resample!-Tuple{WeightedParticles}"><code>MonteCarloMeasurements.resample!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">loglik = resample!(p::WeightedParticles)</code></pre><p>Resample the particles based on the <code>p.logweights</code>. After a call to this function, weights will be reset to sum to one. Returns log-likelihood.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/resampling.jl#L31-L34">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.ribbonplot" href="#MonteCarloMeasurements.ribbonplot"><code>MonteCarloMeasurements.ribbonplot</code></a> — <span class="docstring-category">Function</span>.</div><div><div><p>ribbonplot(x,y,[q=0.025])</p><p>Plots a vector of particles with a ribbon covering quantiles <code>q, 1-q</code>. If <code>q::Tuple</code>, then you can specify both lower and upper quantile, e.g., <code>(0.01, 0.99)</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/plotting.jl#L77-L82">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.set_comparison_function-Tuple{Any}" href="#MonteCarloMeasurements.set_comparison_function-Tuple{Any}"><code>MonteCarloMeasurements.set_comparison_function</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">set_comparison_function(f)</code></pre><p>Change the Function used to reduce particles to a number for comparison operators Toggle the use of a comparison Function without warning using the Function <code>unsafe_comparisons</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/MonteCarloMeasurements.jl#L27-L32">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.sigmapoints-Tuple{Any,AbstractArray{T,2} where T}" href="#MonteCarloMeasurements.sigmapoints-Tuple{Any,AbstractArray{T,2} where T}"><code>MonteCarloMeasurements.sigmapoints</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">sigmapoints(m, Σ)
sigmapoints(d::Normal)
sigmapoints(d::MvNormal)</code></pre><p>The <a href="https://en.wikipedia.org/wiki/Unscented_transform#Sigma_points">unscented transform</a> uses a small number of points to propagate the first and second moments of a probability density, called <em>sigma points</em>. We provide a function <code>sigmapoints(μ, Σ)</code> that creates a <code>Matrix</code> of <code>2n+1</code> sigma points, where <code>n</code> is the dimension. This can be used to initialize any kind of <code>AbstractParticles</code>, e.g.:</p><pre><code class="language-julia">julia&gt; m = [1,2]

julia&gt; Σ = [3. 1; 1 4]

julia&gt; p = StaticParticles(sigmapoints(m,Σ))
2-element Array{StaticParticles{Float64,5},1}:
 (5 StaticParticles: 1.0 ± 1.73)
 (5 StaticParticles: 2.0 ± 2.0)

julia&gt; cov(p) ≈ Σ
true

julia&gt; mean(p) ≈ m
true</code></pre><p>Make sure to pass the variance (not std) as second argument in case <code>μ</code> and <code>Σ</code> are scalars.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/sigmapoints.jl#L1-L24">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.systematic_sample" href="#MonteCarloMeasurements.systematic_sample"><code>MonteCarloMeasurements.systematic_sample</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">systematic_sample(N, d=Normal(0,1); permute=true)</code></pre><p>returns a <code>Vector</code> of length <code>N</code> sampled systematically from the distribution <code>d</code>. If <code>permute=false</code>, this vector will be sorted.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/sampling.jl#L1-L4">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.transform_moments-Tuple{Any,Any,Any}" href="#MonteCarloMeasurements.transform_moments-Tuple{Any,Any,Any}"><code>MonteCarloMeasurements.transform_moments</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">Y = transform_moments(X::Matrix, m, Σ; preserve_latin=false)</code></pre><p>Transforms <code>X</code> such that it get the specified mean and covariance.</p><pre><code class="language-julia">m, Σ   = [1,2], [2 1; 1 4] # Desired mean and covariance
particles = transform_moments(X, m, Σ)
julia&gt; cov(particles) ≈ Σ
true</code></pre><p><strong>Note</strong>, if <code>X</code> is a latin hypercube and <code>Σ</code> is non-diagonal, then the latin property is destroyed for all dimensions but the first. We provide a method <code>preserve_latin=true</code>) which absolutely preserves the latin property in all dimensions, but if you use this, the covariance of the sample will be slightly wrong</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/sigmapoints.jl#L36-L48">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.unsafe_comparisons" href="#MonteCarloMeasurements.unsafe_comparisons"><code>MonteCarloMeasurements.unsafe_comparisons</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">unsafe_comparisons(onoff=true; verbose=true)</code></pre><p>Toggle the use of a comparison function without warning. By default <code>mean</code> is used to reduce particles to a floating point number for comparisons. This function can be changed, example: <code>set_comparison_function(median)</code></p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/MonteCarloMeasurements.jl#L17-L20">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.wasserstein-Tuple{AbstractParticles,AbstractParticles,Any}" href="#MonteCarloMeasurements.wasserstein-Tuple{AbstractParticles,AbstractParticles,Any}"><code>MonteCarloMeasurements.wasserstein</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">wasserstein(p1::AbstractParticles,p2::AbstractParticles,p)</code></pre><p>Returns the Wasserstein distance of order <code>p</code>, to the <code>p</code>th power, between <code>p1</code> and <code>p2</code>. I.e., for <code>p=2</code>, this returns W₂²</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/distances.jl#L1-L6">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.with_workspace-Tuple{Any,Any}" href="#MonteCarloMeasurements.with_workspace-Tuple{Any,Any}"><code>MonteCarloMeasurements.with_workspace</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">with_workspace(f,P)</code></pre><p>In some cases, defining a primitive function which particles are to be propagate through is not possible but allowing unsafe comparisons are not acceptable. One such case is functions that internally calculate eigenvalues of uncertain matrices. The eigenvalue calculation makes use of comparison operators. If the uncertainty is large, eigenvalues might change place in the sorted list of returned eigenvalues, completely ruining downstream computations. For this we recommend, in order of preference</p><ol><li>Use <code>@bymap</code> detailed <a href="https://github.com/baggepinnen/MonteCarloMeasurements.jl#monte-carlo-simulation-by-mappmap">in the documentation</a>. Applicable if all uncertain values appears as arguments to your entry function.</li><li>Create a <code>Workspace</code> object and call it using your entry function. Applicable if uncertain parameters appear nested in an object that is an argument to your entry function:</li></ol><pre><code class="language-julia"># desired computation: y = f(obj), obj contains uncertain parameters inside
y = with_workspace(f, obj)
# or equivalently
w = Workspace(f, obj)
use_invokelatest = true # Set this to false to gain 0.1-1 ms, at the expense of world-age problems if w is created and used in the same function.
w(obj, use_invokelatest)</code></pre></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/deconstruct.jl#L333-L347">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.ℂ2ℂ_function-Union{Tuple{T}, Tuple{F}, Tuple{F,Complex{T}}} where T&lt;:AbstractParticles where F" href="#MonteCarloMeasurements.ℂ2ℂ_function-Union{Tuple{T}, Tuple{F}, Tuple{F,Complex{T}}} where T&lt;:AbstractParticles where F"><code>MonteCarloMeasurements.ℂ2ℂ_function</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ℂ2ℂ_function(f::Function, z::Complex{&lt;:AbstractParticles})</code></pre><p>applies <code>f : ℂ → ℂ</code> to <code>z::Complex{&lt;:AbstractParticles}</code>.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/complex.jl#L13-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.ℝⁿ2ℝⁿ_function-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F,AbstractArray{Particles{T,N},N1} where N1}} where N where T where F" href="#MonteCarloMeasurements.ℝⁿ2ℝⁿ_function-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F,AbstractArray{Particles{T,N},N1} where N1}} where N where T where F"><code>MonteCarloMeasurements.ℝⁿ2ℝⁿ_function</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ℝⁿ2ℝⁿ_function(f::Function, p::AbstractArray{T})</code></pre><p>Applies  <code>f : ℝⁿ → ℝⁿ</code> to an array of particles.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/particles.jl#L111-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.ℝⁿ2ℝⁿ_function-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F,AbstractArray{StaticParticles{T,N},N1} where N1}} where N where T where F" href="#MonteCarloMeasurements.ℝⁿ2ℝⁿ_function-Union{Tuple{N}, Tuple{T}, Tuple{F}, Tuple{F,AbstractArray{StaticParticles{T,N},N1} where N1}} where N where T where F"><code>MonteCarloMeasurements.ℝⁿ2ℝⁿ_function</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ℝⁿ2ℝⁿ_function(f::Function, p::AbstractArray{T})</code></pre><p>Applies  <code>f : ℝⁿ → ℝⁿ</code> to an array of particles.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/particles.jl#L111-L114">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MonteCarloMeasurements.@unsafe-Tuple{Any}" href="#MonteCarloMeasurements.@unsafe-Tuple{Any}"><code>MonteCarloMeasurements.@unsafe</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@unsafe expression</code></pre><p>Activates unsafe comparisons for the provided expression only. The expression is surrounded by a try/catch block to robustly restore unsafe comparisons in case of exception.</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/MonteCarloMeasurements.jl#L37-L40">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:≈-Tuple{AbstractParticles,AbstractParticles}" href="#Base.:≈-Tuple{AbstractParticles,AbstractParticles}"><code>Base.:≈</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">p1 ≈ p2</code></pre><p>Determine if two particles are not significantly different</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/particles.jl#L377-L381">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.:≉-Tuple{AbstractParticles,AbstractParticles}" href="#Base.:≉-Tuple{AbstractParticles,AbstractParticles}"><code>Base.:≉</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">p1 ≉ p2</code></pre><p>Determine if two particles are significantly different</p></div></div><a class="source-link" target="_blank" href="https://github.com/baggepinnen/MonteCarloMeasurements.jl/blob/fbe6622cc8ca0f3ba0e8115117a4b01216e564a4/src/particles.jl#L390-L394">source</a></section><footer><hr/></footer></article></body></html>
